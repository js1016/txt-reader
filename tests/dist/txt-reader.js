/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./factory/txt-reader-for-browser.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./factory/txt-reader-for-browser.js":
/*!*******************************************!*\
  !*** ./factory/txt-reader-for-browser.js ***!
  \*******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _txt_reader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../txt-reader */ \"./txt-reader.ts\");\n/* harmony import */ var _txt_reader__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_txt_reader__WEBPACK_IMPORTED_MODULE_0__);\n\r\nif (typeof window.TxtReader === 'undefined') {\r\n    window.TxtReader = _txt_reader__WEBPACK_IMPORTED_MODULE_0__[\"TxtReader\"];\r\n}\n\n//# sourceURL=webpack:///./factory/txt-reader-for-browser.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/promise-polyfill/src/index.js":
/*!****************************************************!*\
  !*** ./node_modules/promise-polyfill/src/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(setImmediate) {// Store setTimeout reference so promise-polyfill will be unaffected by\n// other code modifying setTimeout (like sinon.useFakeTimers())\nvar setTimeoutFunc = setTimeout;\n\nfunction noop() {}\n\n// Polyfill for Function.prototype.bind\nfunction bind(fn, thisArg) {\n  return function() {\n    fn.apply(thisArg, arguments);\n  };\n}\n\nfunction Promise(fn) {\n  if (!(this instanceof Promise))\n    throw new TypeError('Promises must be constructed via new');\n  if (typeof fn !== 'function') throw new TypeError('not a function');\n  this._state = 0;\n  this._handled = false;\n  this._value = undefined;\n  this._deferreds = [];\n\n  doResolve(fn, this);\n}\n\nfunction handle(self, deferred) {\n  while (self._state === 3) {\n    self = self._value;\n  }\n  if (self._state === 0) {\n    self._deferreds.push(deferred);\n    return;\n  }\n  self._handled = true;\n  Promise._immediateFn(function() {\n    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n      return;\n    }\n    var ret;\n    try {\n      ret = cb(self._value);\n    } catch (e) {\n      reject(deferred.promise, e);\n      return;\n    }\n    resolve(deferred.promise, ret);\n  });\n}\n\nfunction resolve(self, newValue) {\n  try {\n    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n    if (newValue === self)\n      throw new TypeError('A promise cannot be resolved with itself.');\n    if (\n      newValue &&\n      (typeof newValue === 'object' || typeof newValue === 'function')\n    ) {\n      var then = newValue.then;\n      if (newValue instanceof Promise) {\n        self._state = 3;\n        self._value = newValue;\n        finale(self);\n        return;\n      } else if (typeof then === 'function') {\n        doResolve(bind(then, newValue), self);\n        return;\n      }\n    }\n    self._state = 1;\n    self._value = newValue;\n    finale(self);\n  } catch (e) {\n    reject(self, e);\n  }\n}\n\nfunction reject(self, newValue) {\n  self._state = 2;\n  self._value = newValue;\n  finale(self);\n}\n\nfunction finale(self) {\n  if (self._state === 2 && self._deferreds.length === 0) {\n    Promise._immediateFn(function() {\n      if (!self._handled) {\n        Promise._unhandledRejectionFn(self._value);\n      }\n    });\n  }\n\n  for (var i = 0, len = self._deferreds.length; i < len; i++) {\n    handle(self, self._deferreds[i]);\n  }\n  self._deferreds = null;\n}\n\nfunction Handler(onFulfilled, onRejected, promise) {\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, self) {\n  var done = false;\n  try {\n    fn(\n      function(value) {\n        if (done) return;\n        done = true;\n        resolve(self, value);\n      },\n      function(reason) {\n        if (done) return;\n        done = true;\n        reject(self, reason);\n      }\n    );\n  } catch (ex) {\n    if (done) return;\n    done = true;\n    reject(self, ex);\n  }\n}\n\nPromise.prototype['catch'] = function(onRejected) {\n  return this.then(null, onRejected);\n};\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  var prom = new this.constructor(noop);\n\n  handle(this, new Handler(onFulfilled, onRejected, prom));\n  return prom;\n};\n\nPromise.prototype['finally'] = function(callback) {\n  var constructor = this.constructor;\n  return this.then(\n    function(value) {\n      return constructor.resolve(callback()).then(function() {\n        return value;\n      });\n    },\n    function(reason) {\n      return constructor.resolve(callback()).then(function() {\n        return constructor.reject(reason);\n      });\n    }\n  );\n};\n\nPromise.all = function(arr) {\n  return new Promise(function(resolve, reject) {\n    if (!arr || typeof arr.length === 'undefined')\n      throw new TypeError('Promise.all accepts an array');\n    var args = Array.prototype.slice.call(arr);\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n\n    function res(i, val) {\n      try {\n        if (val && (typeof val === 'object' || typeof val === 'function')) {\n          var then = val.then;\n          if (typeof then === 'function') {\n            then.call(\n              val,\n              function(val) {\n                res(i, val);\n              },\n              reject\n            );\n            return;\n          }\n        }\n        args[i] = val;\n        if (--remaining === 0) {\n          resolve(args);\n        }\n      } catch (ex) {\n        reject(ex);\n      }\n    }\n\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.resolve = function(value) {\n  if (value && typeof value === 'object' && value.constructor === Promise) {\n    return value;\n  }\n\n  return new Promise(function(resolve) {\n    resolve(value);\n  });\n};\n\nPromise.reject = function(value) {\n  return new Promise(function(resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function(values) {\n  return new Promise(function(resolve, reject) {\n    for (var i = 0, len = values.length; i < len; i++) {\n      values[i].then(resolve, reject);\n    }\n  });\n};\n\n// Use polyfill for setImmediate for performance gains\nPromise._immediateFn =\n  (typeof setImmediate === 'function' &&\n    function(fn) {\n      setImmediate(fn);\n    }) ||\n  function(fn) {\n    setTimeoutFunc(fn, 0);\n  };\n\nPromise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n  if (typeof console !== 'undefined' && console) {\n    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Promise);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/promise-polyfill/src/index.js?");

/***/ }),

/***/ "./node_modules/promise-polyfill/src/polyfill.js":
/*!*******************************************************!*\
  !*** ./node_modules/promise-polyfill/src/polyfill.js ***!
  \*******************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ \"./node_modules/promise-polyfill/src/index.js\");\n\n\nvar globalNS = (function() {\n  // the only reliable means to get the global object is\n  // `Function('return this')()`\n  // However, this causes CSP violations in Chrome apps.\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  throw new Error('unable to locate global object');\n})();\n\nif (!globalNS.Promise) {\n  globalNS.Promise = _index__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/promise-polyfill/src/polyfill.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6â€“8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/text-encoding-shim/index.js":
/*!**************************************************!*\
  !*** ./node_modules/text-encoding-shim/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\r\n    if (true) {\r\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n    } else { var textEncoding; }\r\n}(this, function () {\r\n\t\"use strict\";\r\n\t// return native implementation if available\r\n\tvar g = typeof GLOBAL !== 'undefined' ? GLOBAL : window;\r\n\tif (typeof g.TextEncoder !== 'undefined' && typeof g.TextDecoder !== 'undefined') {\r\n\t\treturn {'TextEncoder': g.TextEncoder, 'TextDecoder': g.TextDecoder};\r\n\t}\r\n\r\n\t// allowed encoding strings for utf-8\r\n\tvar utf8Encodings = [\r\n\t\t'utf8',\r\n\t\t'utf-8',\r\n\t\t'unicode-1-1-utf-8'\r\n\t];\r\n\r\n\tvar TextEncoder = function(encoding) {\r\n\t\tif (utf8Encodings.indexOf(encoding) < 0 && typeof encoding !== 'undefined' && encoding != null) {\r\n\t\t\tthrow new RangeError('Invalid encoding type. Only utf-8 is supported');\r\n\t\t} else {\r\n\t\t\tthis.encoding = 'utf-8';\r\n\t\t\tthis.encode = function(str) {\r\n\t\t\t\tif (typeof str !== 'string') {\r\n\t\t\t\t\tthrow new TypeError('passed argument must be of tye string');\r\n\t\t\t\t}\r\n\t\t\t\tvar binstr = unescape(encodeURIComponent(str)),\r\n\t\t\t\t\tarr = new Uint8Array(binstr.length);\r\n\t\t\t\tbinstr.split('').forEach(function(char, i) {\r\n\t\t\t\t\tarr[i] = char.charCodeAt(0);\r\n\t\t\t\t});\r\n\t\t\t\treturn arr;\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\tvar TextDecoder = function(encoding, options) {\r\n\t\tif (utf8Encodings.indexOf(encoding) < 0 && typeof encoding !== 'undefined' && encoding != null) {\r\n\t\t\tthrow new RangeError('Invalid encoding type. Only utf-8 is supported');\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.encoding = 'utf-8';\r\n\t\t\tthis.ignoreBOM = false;\r\n\t\t\tthis.fatal = (typeof options !== 'undefined' && fatal in options) ? options.fatal : false;\r\n\t\t\tif (typeof this.fatal !== 'boolean') {\r\n\t\t\t\tthrow new TypeError('fatal flag must be boolean');\r\n\t\t\t}\r\n\t\t\tthis.decode = function (view, options) {\r\n\t\t\t\tif (typeof view === 'undefined') {\r\n\t\t\t\t\treturn '';\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar stream = (typeof options !== 'undefined' && stream in options) ? options.stream : false;\r\n\t\t\t\tif (typeof stream !== 'boolean') {\r\n\t\t\t\t\tthrow new TypeError('stream option must be boolean');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!ArrayBuffer.isView(view)) {\r\n\t\t\t\t\tthrow new TypeError('passed argument must be an array buffer view');\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar arr = new Uint8Array(view.buffer),\r\n\t\t\t\t\t\tcharArr = new Array(arr.length);\r\n\t\t\t\t\tarr.forEach(function(charcode, i) {\r\n\t\t\t\t\t\tcharArr[i] = String.fromCharCode(charcode);\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn decodeURIComponent(escape(charArr.join('')));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn {'TextEncoder': TextEncoder, 'TextDecoder': TextDecoder};\r\n}));\n\n//# sourceURL=webpack:///./node_modules/text-encoding-shim/index.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./polyfill.ts":
/*!*********************!*\
  !*** ./polyfill.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (Uint8Array.prototype.indexOf === undefined) {\r\n    Uint8Array.prototype.indexOf = function (value) {\r\n        return Array.prototype.indexOf.call(this, value);\r\n    };\r\n}\r\nif (Uint8Array.prototype.slice === undefined) {\r\n    Uint8Array.prototype.slice = function (begin, end) {\r\n        return new Uint8Array(Array.prototype.slice.call(this, begin, end));\r\n    };\r\n}\r\nif (!Uint8Array.prototype.forEach) {\r\n    Uint8Array.prototype.forEach = function (callback /*, thisArg*/) {\r\n        var T, k;\r\n        if (this == null) {\r\n            throw new TypeError('this is null or not defined');\r\n        }\r\n        // 1. Let O be the result of calling toObject() passing the\r\n        // |this| value as the argument.\r\n        var O = Object(this);\r\n        // 2. Let lenValue be the result of calling the Get() internal\r\n        // method of O with the argument \"length\".\r\n        // 3. Let len be toUint32(lenValue).\r\n        var len = O.length >>> 0;\r\n        // 4. If isCallable(callback) is false, throw a TypeError exception. \r\n        // See: http://es5.github.com/#x9.11\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError(callback + ' is not a function');\r\n        }\r\n        // 5. If thisArg was supplied, let T be thisArg; else let\r\n        // T be undefined.\r\n        if (arguments.length > 1) {\r\n            T = arguments[1];\r\n        }\r\n        // 6. Let k be 0.\r\n        k = 0;\r\n        // 7. Repeat while k < len.\r\n        while (k < len) {\r\n            var kValue;\r\n            // a. Let Pk be ToString(k).\r\n            //    This is implicit for LHS operands of the in operator.\r\n            // b. Let kPresent be the result of calling the HasProperty\r\n            //    internal method of O with argument Pk.\r\n            //    This step can be combined with c.\r\n            // c. If kPresent is true, then\r\n            if (k in O) {\r\n                // i. Let kValue be the result of calling the Get internal\r\n                // method of O with argument Pk.\r\n                kValue = O[k];\r\n                // ii. Call the Call internal method of callback with T as\r\n                // the this value and argument list containing kValue, k, and O.\r\n                callback.call(T, kValue, k, O);\r\n            }\r\n            // d. Increase k by 1.\r\n            k++;\r\n        }\r\n        // 8. return undefined.\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack:///./polyfill.ts?");

/***/ }),

/***/ "./text-encoding.ts":
/*!**************************!*\
  !*** ./text-encoding.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// This file is used to fix an issue in text-encoding-shim\r\n// See https://gitlab.com/PseudoPsycho/text-encoding-shim/issues/1 for details\r\nexports.__esModule = true;\r\nif (typeof window === 'undefined' && typeof self !== 'undefined') {\r\n    self['window'] = self;\r\n}\r\nvar text_encoding_shim_1 = __webpack_require__(/*! text-encoding-shim */ \"./node_modules/text-encoding-shim/index.js\");\r\nexports.TextDecoder = text_encoding_shim_1.TextDecoder;\r\n\n\n//# sourceURL=webpack:///./text-encoding.ts?");

/***/ }),

/***/ "./txt-reader.ts":
/*!***********************!*\
  !*** ./txt-reader.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nexports.__esModule = true;\r\nvar text_encoding_1 = __webpack_require__(/*! ./text-encoding */ \"./text-encoding.ts\");\r\n__webpack_require__(/*! promise-polyfill/src/polyfill */ \"./node_modules/promise-polyfill/src/polyfill.js\");\r\n__webpack_require__(/*! ./polyfill */ \"./polyfill.ts\");\r\nvar RequestMessage = /** @class */ (function () {\r\n    function RequestMessage(action, data) {\r\n        this.action = action;\r\n        this.data = data !== undefined ? data : null;\r\n    }\r\n    return RequestMessage;\r\n}());\r\nvar TxtReaderTaskState;\r\n(function (TxtReaderTaskState) {\r\n    TxtReaderTaskState[TxtReaderTaskState[\"Initialized\"] = 0] = \"Initialized\";\r\n    TxtReaderTaskState[TxtReaderTaskState[\"Queued\"] = 1] = \"Queued\";\r\n    TxtReaderTaskState[TxtReaderTaskState[\"Running\"] = 2] = \"Running\";\r\n    TxtReaderTaskState[TxtReaderTaskState[\"Completed\"] = 3] = \"Completed\";\r\n})(TxtReaderTaskState || (TxtReaderTaskState = {}));\r\nvar TxtReaderTask = /** @class */ (function () {\r\n    function TxtReaderTask(id, reqMsg, parser) {\r\n        var _this = this;\r\n        this.id = id;\r\n        this.requestMessage = reqMsg;\r\n        this.parser = parser;\r\n        this.requestMessage.taskId = id;\r\n        this.state = TxtReaderTaskState.Initialized;\r\n        this.onProgress = null;\r\n        this.startTime = 0;\r\n        // initialize the task promise object, assign the resolve, reject methods.\r\n        this.promise = new Promise(function (resolve, reject) {\r\n            _this.resolve = resolve;\r\n            _this.reject = reject;\r\n        });\r\n    }\r\n    TxtReaderTask.prototype.dispose = function () {\r\n        // release the memory inside promise obejct\r\n        this.resolve = null;\r\n        this.reject = null;\r\n        this.promise = null;\r\n    };\r\n    // run the task, postMessage would be triggered in TxtReader\r\n    // just change the state and record the task start time here\r\n    TxtReaderTask.prototype.run = function () {\r\n        this.state = TxtReaderTaskState.Running;\r\n        this.startTime = new Date().getTime();\r\n    };\r\n    // be called when a task completes no matter it succeeds or fails\r\n    TxtReaderTask.prototype.complete = function (response) {\r\n        this.state = TxtReaderTaskState.Completed;\r\n        var timeTaken = new Date().getTime() - this.startTime;\r\n        if (response.success) {\r\n            var taskResponse = {\r\n                timeTaken: timeTaken,\r\n                message: response.message,\r\n                result: response.result\r\n            };\r\n            this.resolve(taskResponse);\r\n        }\r\n        else {\r\n            this.reject(response.message);\r\n        }\r\n        this.dispose();\r\n    };\r\n    TxtReaderTask.prototype.updateProgress = function (progress) {\r\n        if (this.onProgress !== null) {\r\n            this.onProgress.call(this.parser, progress);\r\n        }\r\n    };\r\n    TxtReaderTask.prototype.then = function (onFulFilled) {\r\n        var _this = this;\r\n        this.promise.then(function (data) {\r\n            onFulFilled.call(_this.parser, data);\r\n        })[\"catch\"](function (reason) { });\r\n        return this;\r\n    };\r\n    TxtReaderTask.prototype[\"catch\"] = function (onFailed) {\r\n        var _this = this;\r\n        this.promise[\"catch\"](function (reason) {\r\n            onFailed.call(_this.parser, reason);\r\n        });\r\n        return this;\r\n    };\r\n    TxtReaderTask.prototype.progress = function (onProgress) {\r\n        this.onProgress = onProgress;\r\n        return this;\r\n    };\r\n    return TxtReaderTask;\r\n}());\r\nvar TxtReader = /** @class */ (function () {\r\n    function TxtReader() {\r\n        var _this = this;\r\n        this.taskList = [];\r\n        this.runningTask = null;\r\n        this.queuedTaskList = [];\r\n        this.verboseLogging = false;\r\n        this.utf8decoder = new text_encoding_1.TextDecoder(\'utf-8\');\r\n        this.lineCount = 0;\r\n        Object.defineProperty(this, \'lineCount\', {\r\n            value: 0,\r\n            writable: false\r\n        });\r\n        this.file = null;\r\n        this.worker = new Worker(window.URL.createObjectURL(new Blob([\"/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, {\\n/******/ \\t\\t\\t\\tconfigurable: false,\\n/******/ \\t\\t\\t\\tenumerable: true,\\n/******/ \\t\\t\\t\\tget: getter\\n/******/ \\t\\t\\t});\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tObject.defineProperty(exports, \\\'__esModule\\\', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module[\\\'default\\\']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, \\\'a\\\', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\\"./txt-reader-worker.ts\\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\\"./node_modules/text-encoding-shim/index.js\\\":\\n/*!**************************************************!*\\\\\\n  !*** ./node_modules/text-encoding-shim/index.js ***!\\n  \\\\**************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\neval(\\\"var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\\\\r\\\\n    if (true) {\\\\r\\\\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\\\\n\\\\t\\\\t\\\\t\\\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \\\'function\\\' ?\\\\n\\\\t\\\\t\\\\t\\\\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\\\\n\\\\t\\\\t\\\\t\\\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\\\r\\\\n    } else { var textEncoding; }\\\\r\\\\n}(this, function () {\\\\r\\\\n\\\\t\\\\\\\"use strict\\\\\\\";\\\\r\\\\n\\\\t// return native implementation if available\\\\r\\\\n\\\\tvar g = typeof GLOBAL !== \\\'undefined\\\' ? GLOBAL : window;\\\\r\\\\n\\\\tif (typeof g.TextEncoder !== \\\'undefined\\\' && typeof g.TextDecoder !== \\\'undefined\\\') {\\\\r\\\\n\\\\t\\\\treturn {\\\'TextEncoder\\\': g.TextEncoder, \\\'TextDecoder\\\': g.TextDecoder};\\\\r\\\\n\\\\t}\\\\r\\\\n\\\\r\\\\n\\\\t// allowed encoding strings for utf-8\\\\r\\\\n\\\\tvar utf8Encodings = [\\\\r\\\\n\\\\t\\\\t\\\'utf8\\\',\\\\r\\\\n\\\\t\\\\t\\\'utf-8\\\',\\\\r\\\\n\\\\t\\\\t\\\'unicode-1-1-utf-8\\\'\\\\r\\\\n\\\\t];\\\\r\\\\n\\\\r\\\\n\\\\tvar TextEncoder = function(encoding) {\\\\r\\\\n\\\\t\\\\tif (utf8Encodings.indexOf(encoding) < 0 && typeof encoding !== \\\'undefined\\\' && encoding != null) {\\\\r\\\\n\\\\t\\\\t\\\\tthrow new RangeError(\\\'Invalid encoding type. Only utf-8 is supported\\\');\\\\r\\\\n\\\\t\\\\t} else {\\\\r\\\\n\\\\t\\\\t\\\\tthis.encoding = \\\'utf-8\\\';\\\\r\\\\n\\\\t\\\\t\\\\tthis.encode = function(str) {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\tif (typeof str !== \\\'string\\\') {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tthrow new TypeError(\\\'passed argument must be of tye string\\\');\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\r\\\\n\\\\t\\\\t\\\\t\\\\tvar binstr = unescape(encodeURIComponent(str)),\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tarr = new Uint8Array(binstr.length);\\\\r\\\\n\\\\t\\\\t\\\\t\\\\tbinstr.split(\\\'\\\').forEach(function(char, i) {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tarr[i] = char.charCodeAt(0);\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t});\\\\r\\\\n\\\\t\\\\t\\\\t\\\\treturn arr;\\\\r\\\\n\\\\t\\\\t\\\\t};\\\\r\\\\n\\\\t\\\\t}\\\\r\\\\n\\\\t}\\\\r\\\\n\\\\r\\\\n\\\\tvar TextDecoder = function(encoding, options) {\\\\r\\\\n\\\\t\\\\tif (utf8Encodings.indexOf(encoding) < 0 && typeof encoding !== \\\'undefined\\\' && encoding != null) {\\\\r\\\\n\\\\t\\\\t\\\\tthrow new RangeError(\\\'Invalid encoding type. Only utf-8 is supported\\\');\\\\r\\\\n\\\\t\\\\t}\\\\r\\\\n\\\\t\\\\telse {\\\\r\\\\n\\\\t\\\\t\\\\tthis.encoding = \\\'utf-8\\\';\\\\r\\\\n\\\\t\\\\t\\\\tthis.ignoreBOM = false;\\\\r\\\\n\\\\t\\\\t\\\\tthis.fatal = (typeof options !== \\\'undefined\\\' && fatal in options) ? options.fatal : false;\\\\r\\\\n\\\\t\\\\t\\\\tif (typeof this.fatal !== \\\'boolean\\\') {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\tthrow new TypeError(\\\'fatal flag must be boolean\\\');\\\\r\\\\n\\\\t\\\\t\\\\t}\\\\r\\\\n\\\\t\\\\t\\\\tthis.decode = function (view, options) {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\tif (typeof view === \\\'undefined\\\') {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\treturn \\\'\\\';\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\r\\\\n\\\\r\\\\n\\\\t\\\\t\\\\t\\\\tvar stream = (typeof options !== \\\'undefined\\\' && stream in options) ? options.stream : false;\\\\r\\\\n\\\\t\\\\t\\\\t\\\\tif (typeof stream !== \\\'boolean\\\') {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tthrow new TypeError(\\\'stream option must be boolean\\\');\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\r\\\\n\\\\r\\\\n\\\\t\\\\t\\\\t\\\\tif (!ArrayBuffer.isView(view)) {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tthrow new TypeError(\\\'passed argument must be an array buffer view\\\');\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t} else {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvar arr = new Uint8Array(view.buffer),\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcharArr = new Array(arr.length);\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tarr.forEach(function(charcode, i) {\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcharArr[i] = String.fromCharCode(charcode);\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t});\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\treturn decodeURIComponent(escape(charArr.join(\\\'\\\')));\\\\r\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\r\\\\n\\\\t\\\\t\\\\t}\\\\r\\\\n\\\\t\\\\t}\\\\r\\\\n\\\\t}\\\\r\\\\n\\\\treturn {\\\'TextEncoder\\\': TextEncoder, \\\'TextDecoder\\\': TextDecoder};\\\\r\\\\n}));\\\\n\\\\n//# sourceURL=webpack:///./node_modules/text-encoding-shim/index.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./polyfill.ts\\\":\\n/*!*********************!*\\\\\\n  !*** ./polyfill.ts ***!\\n  \\\\*********************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\neval(\\\"if (Uint8Array.prototype.indexOf === undefined) {\\\\r\\\\n    Uint8Array.prototype.indexOf = function (value) {\\\\r\\\\n        return Array.prototype.indexOf.call(this, value);\\\\r\\\\n    };\\\\r\\\\n}\\\\r\\\\nif (Uint8Array.prototype.slice === undefined) {\\\\r\\\\n    Uint8Array.prototype.slice = function (begin, end) {\\\\r\\\\n        return new Uint8Array(Array.prototype.slice.call(this, begin, end));\\\\r\\\\n    };\\\\r\\\\n}\\\\r\\\\nif (!Uint8Array.prototype.forEach) {\\\\r\\\\n    Uint8Array.prototype.forEach = function (callback /*, thisArg*/) {\\\\r\\\\n        var T, k;\\\\r\\\\n        if (this == null) {\\\\r\\\\n            throw new TypeError(\\\'this is null or not defined\\\');\\\\r\\\\n        }\\\\r\\\\n        // 1. Let O be the result of calling toObject() passing the\\\\r\\\\n        // |this| value as the argument.\\\\r\\\\n        var O = Object(this);\\\\r\\\\n        // 2. Let lenValue be the result of calling the Get() internal\\\\r\\\\n        // method of O with the argument \\\\\\\"length\\\\\\\".\\\\r\\\\n        // 3. Let len be toUint32(lenValue).\\\\r\\\\n        var len = O.length >>> 0;\\\\r\\\\n        // 4. If isCallable(callback) is false, throw a TypeError exception. \\\\r\\\\n        // See: http://es5.github.com/#x9.11\\\\r\\\\n        if (typeof callback !== \\\'function\\\') {\\\\r\\\\n            throw new TypeError(callback + \\\' is not a function\\\');\\\\r\\\\n        }\\\\r\\\\n        // 5. If thisArg was supplied, let T be thisArg; else let\\\\r\\\\n        // T be undefined.\\\\r\\\\n        if (arguments.length > 1) {\\\\r\\\\n            T = arguments[1];\\\\r\\\\n        }\\\\r\\\\n        // 6. Let k be 0.\\\\r\\\\n        k = 0;\\\\r\\\\n        // 7. Repeat while k < len.\\\\r\\\\n        while (k < len) {\\\\r\\\\n            var kValue;\\\\r\\\\n            // a. Let Pk be ToString(k).\\\\r\\\\n            //    This is implicit for LHS operands of the in operator.\\\\r\\\\n            // b. Let kPresent be the result of calling the HasProperty\\\\r\\\\n            //    internal method of O with argument Pk.\\\\r\\\\n            //    This step can be combined with c.\\\\r\\\\n            // c. If kPresent is true, then\\\\r\\\\n            if (k in O) {\\\\r\\\\n                // i. Let kValue be the result of calling the Get internal\\\\r\\\\n                // method of O with argument Pk.\\\\r\\\\n                kValue = O[k];\\\\r\\\\n                // ii. Call the Call internal method of callback with T as\\\\r\\\\n                // the this value and argument list containing kValue, k, and O.\\\\r\\\\n                callback.call(T, kValue, k, O);\\\\r\\\\n            }\\\\r\\\\n            // d. Increase k by 1.\\\\r\\\\n            k++;\\\\r\\\\n        }\\\\r\\\\n        // 8. return undefined.\\\\r\\\\n    };\\\\r\\\\n}\\\\r\\\\n\\\\n\\\\n//# sourceURL=webpack:///./polyfill.ts?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./text-encoding.ts\\\":\\n/*!**************************!*\\\\\\n  !*** ./text-encoding.ts ***!\\n  \\\\**************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"\\\\r\\\\n// This file is used to fix an issue in text-encoding-shim\\\\r\\\\n// See https://gitlab.com/PseudoPsycho/text-encoding-shim/issues/1 for details\\\\r\\\\nexports.__esModule = true;\\\\r\\\\nif (typeof window === \\\'undefined\\\' && typeof self !== \\\'undefined\\\') {\\\\r\\\\n    self[\\\'window\\\'] = self;\\\\r\\\\n}\\\\r\\\\nvar text_encoding_shim_1 = __webpack_require__(/*! text-encoding-shim */ \\\\\\\"./node_modules/text-encoding-shim/index.js\\\\\\\");\\\\r\\\\nexports.TextDecoder = text_encoding_shim_1.TextDecoder;\\\\r\\\\n\\\\n\\\\n//# sourceURL=webpack:///./text-encoding.ts?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./txt-reader-worker.ts\\\":\\n/*!******************************!*\\\\\\n  !*** ./txt-reader-worker.ts ***!\\n  \\\\******************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"\\\\r\\\\nexports.__esModule = true;\\\\r\\\\nvar text_encoding_1 = __webpack_require__(/*! ./text-encoding */ \\\\\\\"./text-encoding.ts\\\\\\\");\\\\r\\\\n__webpack_require__(/*! ./polyfill */ \\\\\\\"./polyfill.ts\\\\\\\");\\\\r\\\\nvar utf8decoder = new text_encoding_1.TextDecoder(\\\'utf-8\\\');\\\\r\\\\nvar DEFAULT_CHUNK_SIZE = 1024 * 1024 * 50;\\\\r\\\\nvar currentTaskId = null;\\\\r\\\\nvar txtReaderWorker = null;\\\\r\\\\nvar verboseLogging = false;\\\\r\\\\nvar useTransferrable = navigator.userAgent.indexOf(\\\'Firefox\\\') > -1;\\\\r\\\\nvar respondMessage = function (responseMessage) {\\\\r\\\\n    if (responseMessage.done) {\\\\r\\\\n        currentTaskId = null;\\\\r\\\\n    }\\\\r\\\\n    postMessage.apply(null, [responseMessage]);\\\\r\\\\n};\\\\r\\\\nvar respondTransferrableMessage = function (responseMessage, arr) {\\\\r\\\\n    if (responseMessage.done) {\\\\r\\\\n        currentTaskId = null;\\\\r\\\\n    }\\\\r\\\\n    postMessage.apply(null, [responseMessage, arr]);\\\\r\\\\n};\\\\r\\\\nvar createProgressResponseMessage = function (progress) {\\\\r\\\\n    var responseMessage = new ResponseMessage(progress);\\\\r\\\\n    responseMessage.done = false;\\\\r\\\\n    return responseMessage;\\\\r\\\\n};\\\\r\\\\nvar validateWorker = function () {\\\\r\\\\n    if (txtReaderWorker === null) {\\\\r\\\\n        respondMessage(new ResponseMessage(false, \\\'File has not been loaded into the worker, need to loadFile first.\\\'));\\\\r\\\\n        return false;\\\\r\\\\n    }\\\\r\\\\n    return true;\\\\r\\\\n};\\\\r\\\\nvar mergeUint8Array = function (x, y) {\\\\r\\\\n    if (x.byteLength === 0) {\\\\r\\\\n        return y;\\\\r\\\\n    }\\\\r\\\\n    if (y.byteLength === 0) {\\\\r\\\\n        return x;\\\\r\\\\n    }\\\\r\\\\n    var z = new Uint8Array(x.byteLength + y.byteLength);\\\\r\\\\n    z.set(x, 0);\\\\r\\\\n    z.set(y, x.byteLength);\\\\r\\\\n    return z;\\\\r\\\\n};\\\\r\\\\nself.addEventListener(\\\'message\\\', function (event) {\\\\r\\\\n    var req = event.data;\\\\r\\\\n    if (verboseLogging) {\\\\r\\\\n        console.log(\\\'Worker thread received a message from main thread: \\\\\\\\r\\\\\\\\n\\\', event.data);\\\\r\\\\n    }\\\\r\\\\n    if (currentTaskId !== null) {\\\\r\\\\n        throw (\\\'The worker thread is busy.\\\');\\\\r\\\\n    }\\\\r\\\\n    currentTaskId = req.taskId;\\\\r\\\\n    switch (req.action) {\\\\r\\\\n        case \\\'loadFile\\\':\\\\r\\\\n            txtReaderWorker = new TxtReaderWorker(req.data.file, req.data.config);\\\\r\\\\n            break;\\\\r\\\\n        case \\\'enableVerbose\\\':\\\\r\\\\n            verboseLogging = true;\\\\r\\\\n            respondMessage(new ResponseMessage(true));\\\\r\\\\n            break;\\\\r\\\\n        case \\\'setChunkSize\\\':\\\\r\\\\n            if (typeof req.data !== \\\'number\\\' || req.data < 1) {\\\\r\\\\n                respondMessage(new ResponseMessage(false, \\\'Invalid CHUNK_SIZE, must be greater than 1.\\\'));\\\\r\\\\n                return;\\\\r\\\\n            }\\\\r\\\\n            if (txtReaderWorker) {\\\\r\\\\n                txtReaderWorker.CHUNK_SIZE = req.data;\\\\r\\\\n            }\\\\r\\\\n            DEFAULT_CHUNK_SIZE = req.data;\\\\r\\\\n            respondMessage(new ResponseMessage(DEFAULT_CHUNK_SIZE));\\\\r\\\\n            break;\\\\r\\\\n        case \\\'getLines\\\':\\\\r\\\\n            if (validateWorker()) {\\\\r\\\\n                txtReaderWorker.getLines(req.data.start, req.data.count);\\\\r\\\\n            }\\\\r\\\\n            break;\\\\r\\\\n        case \\\'iterateLines\\\':\\\\r\\\\n            if (validateWorker()) {\\\\r\\\\n                txtReaderWorker.iterateLines(req.data);\\\\r\\\\n            }\\\\r\\\\n            break;\\\\r\\\\n    }\\\\r\\\\n});\\\\r\\\\nvar ResponseMessage = /** @class */ (function () {\\\\r\\\\n    function ResponseMessage(x, y, z) {\\\\r\\\\n        this.taskId = currentTaskId;\\\\r\\\\n        if (arguments.length === 1) {\\\\r\\\\n            this.success = true;\\\\r\\\\n            this.message = \\\'\\\';\\\\r\\\\n            this.result = x;\\\\r\\\\n        }\\\\r\\\\n        else if (arguments.length === 2) {\\\\r\\\\n            switch (typeof x) {\\\\r\\\\n                case \\\'boolean\\\':\\\\r\\\\n                    this.success = x;\\\\r\\\\n                    this.message = y;\\\\r\\\\n                    this.result = null;\\\\r\\\\n                    break;\\\\r\\\\n                default:\\\\r\\\\n                    this.success = true;\\\\r\\\\n                    this.message = x;\\\\r\\\\n                    this.result = y;\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            this.success = x;\\\\r\\\\n            this.message = y;\\\\r\\\\n            this.result = z;\\\\r\\\\n        }\\\\r\\\\n        this.done = true;\\\\r\\\\n    }\\\\r\\\\n    return ResponseMessage;\\\\r\\\\n}());\\\\r\\\\nvar Iterator = /** @class */ (function () {\\\\r\\\\n    function Iterator() {\\\\r\\\\n        this.lineView = new Uint8Array(0);\\\\r\\\\n        this.lastViewEndsWithCR = false;\\\\r\\\\n        this.onEachLineInternal = null;\\\\r\\\\n        this.onEachLine = null;\\\\r\\\\n        this.eachLineScope = null;\\\\r\\\\n        this.onSeekComplete = null;\\\\r\\\\n        this.offset = 0;\\\\r\\\\n        this.createMap = false;\\\\r\\\\n        this.endOffset = null;\\\\r\\\\n        this.linesToIterate = 0;\\\\r\\\\n        this.linesProcessed = 0;\\\\r\\\\n        this.currentLineNumber = 1;\\\\r\\\\n        this.startLineNumber = 0;\\\\r\\\\n        this.lastProgress = null;\\\\r\\\\n        this.processedViewLength = 0;\\\\r\\\\n        this.lineBreakLength = 0;\\\\r\\\\n        this.map = [];\\\\r\\\\n        this.lastMappedProgress = null;\\\\r\\\\n    }\\\\r\\\\n    Iterator.prototype.shouldBreak = function () {\\\\r\\\\n        if (this.isPartialIterate() && this.linesProcessed === this.linesToIterate) {\\\\r\\\\n            return true;\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            return false;\\\\r\\\\n        }\\\\r\\\\n    };\\\\r\\\\n    Iterator.prototype.isPartialIterate = function () {\\\\r\\\\n        return this.linesToIterate > 0;\\\\r\\\\n    };\\\\r\\\\n    Iterator.prototype.hitLine = function (lineData) {\\\\r\\\\n        var isPartialIterate = this.isPartialIterate();\\\\r\\\\n        var progress = 0;\\\\r\\\\n        if (!isPartialIterate ||\\\\r\\\\n            (isPartialIterate && this.currentLineNumber >= this.startLineNumber)) {\\\\r\\\\n            this.linesProcessed++;\\\\r\\\\n            if (isPartialIterate) {\\\\r\\\\n                progress = Math.round(this.linesProcessed / this.linesToIterate * 10000) / 100;\\\\r\\\\n            }\\\\r\\\\n            else {\\\\r\\\\n                progress = Math.round(this.processedViewLength / this.endOffset * 10000) / 100;\\\\r\\\\n            }\\\\r\\\\n            if (this.createMap) {\\\\r\\\\n                var currentProgress = Math.round(progress);\\\\r\\\\n                if (this.lastMappedProgress === null ||\\\\r\\\\n                    this.lastMappedProgress < currentProgress) {\\\\r\\\\n                    this.lastMappedProgress = currentProgress;\\\\r\\\\n                    this.map.push({\\\\r\\\\n                        line: this.currentLineNumber,\\\\r\\\\n                        offset: this.processedViewLength\\\\r\\\\n                    });\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n            if (this.onEachLineInternal !== null) {\\\\r\\\\n                if (lineData.buffer.byteLength != lineData.byteLength) {\\\\r\\\\n                    lineData = new Uint8Array(lineData);\\\\r\\\\n                }\\\\r\\\\n                this.onEachLineInternal.call(self, lineData, progress);\\\\r\\\\n            }\\\\r\\\\n            if (this.onEachLine !== null) {\\\\r\\\\n                if (lineData.buffer.byteLength != lineData.byteLength) {\\\\r\\\\n                    lineData = new Uint8Array(lineData);\\\\r\\\\n                }\\\\r\\\\n                this.onEachLine.call(this.eachLineScope, lineData, progress, this.currentLineNumber);\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        if (isPartialIterate) {\\\\r\\\\n            if (this.shouldReportProgress(progress)) {\\\\r\\\\n                this.lastProgress = progress;\\\\r\\\\n                respondMessage(createProgressResponseMessage(progress < 100 ? progress : 100));\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        this.processedViewLength += lineData.length + this.lineBreakLength;\\\\r\\\\n        this.currentLineNumber++;\\\\r\\\\n    };\\\\r\\\\n    Iterator.prototype.shouldReportProgress = function (currentProgress) {\\\\r\\\\n        if (this.lastProgress === null) {\\\\r\\\\n            return true;\\\\r\\\\n        }\\\\r\\\\n        else if (currentProgress - this.lastProgress > 5) {\\\\r\\\\n            return true;\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            return false;\\\\r\\\\n        }\\\\r\\\\n    };\\\\r\\\\n    Iterator.prototype.bindEachLineFromConfig = function (config) {\\\\r\\\\n        this.onEachLine = new Function(\\\'return \\\' + config.eachLine)();\\\\r\\\\n        this.eachLineScope = config.scope;\\\\r\\\\n        this.eachLineScope[\\\'decode\\\'] = function (value) {\\\\r\\\\n            return utf8decoder.decode(value);\\\\r\\\\n        };\\\\r\\\\n    };\\\\r\\\\n    return Iterator;\\\\r\\\\n}());\\\\r\\\\nvar TxtReaderWorker = /** @class */ (function () {\\\\r\\\\n    function TxtReaderWorker(file, onNewLineConfig) {\\\\r\\\\n        var _this = this;\\\\r\\\\n        if (Object.prototype.toString.call(file).toLowerCase() !== \\\'[object file]\\\') {\\\\r\\\\n            respondMessage(new ResponseMessage(false, \\\'Invalid file object\\\'));\\\\r\\\\n            return;\\\\r\\\\n        }\\\\r\\\\n        this.CHUNK_SIZE = DEFAULT_CHUNK_SIZE;\\\\r\\\\n        this.file = file;\\\\r\\\\n        this.lineCount = 0;\\\\r\\\\n        this.quickSearchMap = [];\\\\r\\\\n        this.fr = new FileReader();\\\\r\\\\n        this.fr.onload = function () {\\\\r\\\\n            var view = new Uint8Array(_this.fr.result);\\\\r\\\\n            var viewTotalLength = _this.fr.result.byteLength;\\\\r\\\\n            var iterator = _this.iterator;\\\\r\\\\n            while (view.length > 0) {\\\\r\\\\n                // first CR (0x0D, \\\\\\\\r) position in the view\\\\r\\\\n                var crIndex = view.indexOf(13);\\\\r\\\\n                // first LF (0x0A, \\\\\\\\n) position in the view\\\\r\\\\n                var lfIndex = view.indexOf(10);\\\\r\\\\n                // for CRLF linebreakLength would be 2, otherwise the value would be 1.\\\\r\\\\n                var lineBreakIndex = void 0;\\\\r\\\\n                // If merge all view to lineView\\\\r\\\\n                var mergeAll = false;\\\\r\\\\n                // If current view ends with CR\\\\r\\\\n                var endsWithCR = false;\\\\r\\\\n                if (crIndex > 0 && (lfIndex === -1 || crIndex < lfIndex)) {\\\\r\\\\n                    // CR is hit before LF in the view or there is only CR hit in the view\\\\r\\\\n                    // CR is in the middle or end\\\\r\\\\n                    if (crIndex < view.length - 1) {\\\\r\\\\n                        // CR in the middle\\\\r\\\\n                        if (view[crIndex + 1] === 10) {\\\\r\\\\n                            // CRLF\\\\r\\\\n                            lineBreakIndex = crIndex;\\\\r\\\\n                            iterator.lineBreakLength = 2;\\\\r\\\\n                        }\\\\r\\\\n                        else {\\\\r\\\\n                            // CR only in the middle\\\\r\\\\n                            lineBreakIndex = crIndex;\\\\r\\\\n                            iterator.lineBreakLength = 1;\\\\r\\\\n                        }\\\\r\\\\n                    }\\\\r\\\\n                    else {\\\\r\\\\n                        // CR in the end, do MERGEALL first since not sure the linebreak is CR or CRLF\\\\r\\\\n                        endsWithCR = true;\\\\r\\\\n                        mergeAll = true;\\\\r\\\\n                    }\\\\r\\\\n                }\\\\r\\\\n                else if (crIndex === 0) {\\\\r\\\\n                    // CR is the first byte\\\\r\\\\n                    if (view.length > 1) {\\\\r\\\\n                        if (view[1] === 10) {\\\\r\\\\n                            // CRLF at beginning\\\\r\\\\n                            lineBreakIndex = crIndex;\\\\r\\\\n                            iterator.lineBreakLength = 2;\\\\r\\\\n                        }\\\\r\\\\n                        else {\\\\r\\\\n                            // CR only at beginning\\\\r\\\\n                            lineBreakIndex = crIndex;\\\\r\\\\n                            iterator.lineBreakLength = 1;\\\\r\\\\n                        }\\\\r\\\\n                    }\\\\r\\\\n                    else {\\\\r\\\\n                        // rare scenario: view length is 1 and the content is CR, CR is not only the first byte but also the last byte\\\\r\\\\n                        // do MERGEALL first since not sure the linebreak is CR or CRLF\\\\r\\\\n                        endsWithCR = true;\\\\r\\\\n                        mergeAll = true;\\\\r\\\\n                    }\\\\r\\\\n                }\\\\r\\\\n                else {\\\\r\\\\n                    // no CR in the view or LF is hit before CR\\\\r\\\\n                    if (lfIndex > 0) {\\\\r\\\\n                        // LF is in the middle or end, no need to check the CRLF scenario since no CR is found before LF postion\\\\r\\\\n                        lineBreakIndex = lfIndex;\\\\r\\\\n                        iterator.lineBreakLength = 1;\\\\r\\\\n                    }\\\\r\\\\n                    else if (lfIndex === 0) {\\\\r\\\\n                        // LF is the first byte, need to check if the last byte of lineView is CR\\\\r\\\\n                        iterator.lineBreakLength = iterator.lastViewEndsWithCR ? 2 : 1;\\\\r\\\\n                        iterator.hitLine(iterator.lastViewEndsWithCR ? iterator.lineView.slice(0, iterator.lineView.length - 1) : iterator.lineView);\\\\r\\\\n                        if (iterator.shouldBreak()) {\\\\r\\\\n                            break;\\\\r\\\\n                        }\\\\r\\\\n                        iterator.lineView = new Uint8Array(0);\\\\r\\\\n                        view = new Uint8Array(_this.fr.result, 1 + view.byteOffset);\\\\r\\\\n                        iterator.lastViewEndsWithCR = false;\\\\r\\\\n                        continue;\\\\r\\\\n                    }\\\\r\\\\n                    else {\\\\r\\\\n                        // no LF found\\\\r\\\\n                        mergeAll = true;\\\\r\\\\n                    }\\\\r\\\\n                }\\\\r\\\\n                if (!mergeAll) {\\\\r\\\\n                    if (iterator.lastViewEndsWithCR) {\\\\r\\\\n                        // lineView is like: ****CR, just treat **** as a new line, no need to check if the current view starts with LF since it is handled by LF first byte scenario\\\\r\\\\n                        iterator.hitLine(iterator.lineView.slice(0, iterator.lineView.length - 1));\\\\r\\\\n                        if (iterator.shouldBreak()) {\\\\r\\\\n                            break;\\\\r\\\\n                        }\\\\r\\\\n                        // treat the view as a new line\\\\r\\\\n                        iterator.hitLine(view.slice(0, lineBreakIndex));\\\\r\\\\n                        if (iterator.shouldBreak()) {\\\\r\\\\n                            break;\\\\r\\\\n                        }\\\\r\\\\n                        // reset lastViewEndsWithCR to prevent it being treated again for next view\\\\r\\\\n                        iterator.lastViewEndsWithCR = false;\\\\r\\\\n                    }\\\\r\\\\n                    else {\\\\r\\\\n                        // merge the view line into lineView\\\\r\\\\n                        iterator.lineView = mergeUint8Array(iterator.lineView, view.slice(0, lineBreakIndex));\\\\r\\\\n                        // treat the lineView as a whole line\\\\r\\\\n                        iterator.hitLine(iterator.lineView);\\\\r\\\\n                        if (iterator.shouldBreak()) {\\\\r\\\\n                            break;\\\\r\\\\n                        }\\\\r\\\\n                    }\\\\r\\\\n                    // clear lineView\\\\r\\\\n                    iterator.lineView = new Uint8Array(0);\\\\r\\\\n                    // remove the processed view\\\\r\\\\n                    view = new Uint8Array(_this.fr.result, view.byteOffset + lineBreakIndex + iterator.lineBreakLength);\\\\r\\\\n                }\\\\r\\\\n                else {\\\\r\\\\n                    // do merge all, which means no CR or LF found\\\\r\\\\n                    if (iterator.lastViewEndsWithCR) {\\\\r\\\\n                        // lineView is like: ****CR, just treat **** as a new line\\\\r\\\\n                        iterator.lineBreakLength = 1;\\\\r\\\\n                        iterator.hitLine(iterator.lineView.slice(0, iterator.lineView.length - 1));\\\\r\\\\n                        if (iterator.shouldBreak()) {\\\\r\\\\n                            break;\\\\r\\\\n                        }\\\\r\\\\n                        // clear lineView\\\\r\\\\n                        iterator.lineView = new Uint8Array(0);\\\\r\\\\n                    }\\\\r\\\\n                    // merge the view to lineView\\\\r\\\\n                    iterator.lineView = mergeUint8Array(iterator.lineView, view);\\\\r\\\\n                    iterator.lastViewEndsWithCR = endsWithCR;\\\\r\\\\n                    break; // break the while as all rest view is processed\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n            if (!iterator.isPartialIterate()) {\\\\r\\\\n                var progress = Math.round(iterator.offset / _this.file.size * 10000) / 100;\\\\r\\\\n                respondMessage(createProgressResponseMessage(progress < 100 ? progress : 100));\\\\r\\\\n            }\\\\r\\\\n            iterator.offset += _this.CHUNK_SIZE;\\\\r\\\\n            iterator.lineBreakLength = 0;\\\\r\\\\n            _this.seek();\\\\r\\\\n        };\\\\r\\\\n        this.iterator = new Iterator();\\\\r\\\\n        this.iterator.createMap = true;\\\\r\\\\n        this.iterator.endOffset = this.file.size;\\\\r\\\\n        if (onNewLineConfig) {\\\\r\\\\n            this.iterator.bindEachLineFromConfig(onNewLineConfig);\\\\r\\\\n        }\\\\r\\\\n        this.iterateLinesInternal(function (line, progress) {\\\\r\\\\n            _this.lineCount++;\\\\r\\\\n        }, function () {\\\\r\\\\n            _this.quickSearchMap = _this.iterator.map;\\\\r\\\\n            var result = {\\\\r\\\\n                lineCount: _this.lineCount\\\\r\\\\n            };\\\\r\\\\n            if (onNewLineConfig) {\\\\r\\\\n                delete _this.iterator.eachLineScope[\\\'decode\\\'];\\\\r\\\\n                result.scope = _this.iterator.eachLineScope;\\\\r\\\\n            }\\\\r\\\\n            respondMessage(new ResponseMessage(result));\\\\r\\\\n        });\\\\r\\\\n    }\\\\r\\\\n    TxtReaderWorker.prototype.setPartialIterator = function (start, count) {\\\\r\\\\n        if (start < 1 || start > this.lineCount) {\\\\r\\\\n            respondMessage(new ResponseMessage(false, \\\'Start line number is invalid\\\'));\\\\r\\\\n            return false;\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            var endLineNumber = start + count - 1;\\\\r\\\\n            endLineNumber = endLineNumber > this.lineCount ? this.lineCount : endLineNumber;\\\\r\\\\n            for (var i = 0; i < this.quickSearchMap.length; i++) {\\\\r\\\\n                if (start >= this.quickSearchMap[i].line && (i === this.quickSearchMap.length - 1 || start < this.quickSearchMap[i + 1].line)) {\\\\r\\\\n                    this.iterator.offset = this.quickSearchMap[i].offset;\\\\r\\\\n                    this.iterator.currentLineNumber = this.quickSearchMap[i].line;\\\\r\\\\n                }\\\\r\\\\n                if (endLineNumber < this.quickSearchMap[i].line && (i === 0 || endLineNumber >= this.quickSearchMap[i - 1].line)) {\\\\r\\\\n                    this.iterator.endOffset = this.quickSearchMap[i].offset;\\\\r\\\\n                }\\\\r\\\\n                else {\\\\r\\\\n                    this.iterator.endOffset = this.file.size;\\\\r\\\\n                }\\\\r\\\\n            }\\\\r\\\\n            this.iterator.linesToIterate = count;\\\\r\\\\n            this.iterator.startLineNumber = start;\\\\r\\\\n            return true;\\\\r\\\\n        }\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.iterateLinesInternal = function (onNewLineFunc, onSeekCompleteFunc) {\\\\r\\\\n        this.iterator.onEachLineInternal = onNewLineFunc;\\\\r\\\\n        this.iterator.onSeekComplete = onSeekCompleteFunc || null;\\\\r\\\\n        this.seek();\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.iterateLines = function (data) {\\\\r\\\\n        var _this = this;\\\\r\\\\n        var config = data.config;\\\\r\\\\n        this.iterator.offset = 0;\\\\r\\\\n        this.iterator.endOffset = this.file.size;\\\\r\\\\n        this.iterator.bindEachLineFromConfig(config);\\\\r\\\\n        this.iterator.onSeekComplete = function () {\\\\r\\\\n            delete _this.iterator.eachLineScope[\\\'decode\\\'];\\\\r\\\\n            respondMessage(new ResponseMessage(_this.iterator.eachLineScope));\\\\r\\\\n        };\\\\r\\\\n        if (data.start !== null && data.count !== null) {\\\\r\\\\n            var setResult = this.setPartialIterator(data.start, data.count);\\\\r\\\\n            if (!setResult) {\\\\r\\\\n                return;\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        this.seek();\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.seek = function () {\\\\r\\\\n        var finishDueToLinesToIterateReached = this.iterator.linesToIterate > 0 && this.iterator.linesProcessed === this.iterator.linesToIterate;\\\\r\\\\n        if (this.iterator.offset >= this.iterator.endOffset || finishDueToLinesToIterateReached) {\\\\r\\\\n            respondMessage(createProgressResponseMessage(100));\\\\r\\\\n            if (this.iterator.lineView.byteLength && !finishDueToLinesToIterateReached) {\\\\r\\\\n                this.iterator.hitLine(this.iterator.lineView);\\\\r\\\\n                this.iterator.lineView = new Uint8Array(0);\\\\r\\\\n            }\\\\r\\\\n            if (this.iterator.onSeekComplete !== null) {\\\\r\\\\n                this.iterator.onSeekComplete.call(self);\\\\r\\\\n            }\\\\r\\\\n            this.iterator = new Iterator();\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            var slice = this.file.slice(this.iterator.offset, this.iterator.offset + this.CHUNK_SIZE);\\\\r\\\\n            this.fr.readAsArrayBuffer(slice);\\\\r\\\\n        }\\\\r\\\\n    };\\\\r\\\\n    TxtReaderWorker.prototype.getLines = function (start, count) {\\\\r\\\\n        if (this.setPartialIterator(start, count)) {\\\\r\\\\n            var lines_1 = [];\\\\r\\\\n            var linesBuffer_1 = [];\\\\r\\\\n            this.iterateLinesInternal(function (line) {\\\\r\\\\n                lines_1.push(line);\\\\r\\\\n                if (useTransferrable) {\\\\r\\\\n                    linesBuffer_1.push(line.buffer);\\\\r\\\\n                }\\\\r\\\\n            }, function () {\\\\r\\\\n                if (useTransferrable) {\\\\r\\\\n                    respondTransferrableMessage(new ResponseMessage(lines_1), linesBuffer_1);\\\\r\\\\n                }\\\\r\\\\n                else {\\\\r\\\\n                    respondMessage(new ResponseMessage(lines_1));\\\\r\\\\n                }\\\\r\\\\n            });\\\\r\\\\n        }\\\\r\\\\n    };\\\\r\\\\n    return TxtReaderWorker;\\\\r\\\\n}());\\\\r\\\\n\\\\n\\\\n//# sourceURL=webpack:///./txt-reader-worker.ts?\\\");\\n\\n/***/ })\\n\\n/******/ });\"])));\r\n        this.worker.addEventListener(\'message\', function (event) {\r\n            if (_this.verboseLogging) {\r\n                console.log(\'Main thread received a message from worker thread: \\r\\n\', event.data);\r\n            }\r\n            var response = event.data;\r\n            if (response.taskId !== _this.runningTask.id) {\r\n                throw (\"Received task ID (\" + response.taskId + \") does not match the running task ID (\" + _this.runningTask.id + \").\");\r\n            }\r\n            if (response.done) {\r\n                // the task completes\r\n                _this.completeTask(response);\r\n            }\r\n            else {\r\n                // the task is incomplete, means it is a progress message\r\n                if (Object.prototype.toString.call(response.result).toLowerCase() === \'[object number]\' && response.result >= 0 && response.result <= 100) {\r\n                    _this.runningTask.updateProgress(response.result);\r\n                }\r\n                else {\r\n                    throw (\'Unkown message type\');\r\n                }\r\n            }\r\n        }, false);\r\n    }\r\n    TxtReader.prototype.loadFile = function (file, config) {\r\n        var _this = this;\r\n        this.file = file;\r\n        Object.defineProperty(this, \'lineCount\', {\r\n            value: 0,\r\n            writable: false\r\n        });\r\n        var data = {\r\n            file: file\r\n        };\r\n        if (config) {\r\n            data.config = this.getItertorConfigMessage(config);\r\n        }\r\n        return this.newTask(\'loadFile\', data).then(function (response) {\r\n            Object.defineProperty(_this, \'lineCount\', {\r\n                value: response.result.lineCount,\r\n                writable: false\r\n            });\r\n        });\r\n    };\r\n    TxtReader.prototype.setChunkSize = function (chunkSize) {\r\n        return this.newTask(\'setChunkSize\', chunkSize);\r\n    };\r\n    TxtReader.prototype.enableVerbose = function () {\r\n        this.verboseLogging = true;\r\n        return this.newTask(\'enableVerbose\');\r\n    };\r\n    TxtReader.prototype.getLines = function (start, count) {\r\n        var _this = this;\r\n        return this.newTask(\'getLines\', {\r\n            start: start,\r\n            count: count\r\n        }).then(function (response) {\r\n            for (var i = 0; i < response.result.length; i++) {\r\n                response.result[i] = _this.utf8decoder.decode(response.result[i]);\r\n            }\r\n        });\r\n    };\r\n    TxtReader.prototype.iterateLines = function (config, start, count) {\r\n        return this.newTask(\'iterateLines\', {\r\n            config: this.getItertorConfigMessage(config),\r\n            start: start || null,\r\n            count: count || null\r\n        });\r\n    };\r\n    TxtReader.prototype.getItertorConfigMessage = function (config) {\r\n        return {\r\n            eachLine: config.eachLine.toString(),\r\n            scope: config.scope || {}\r\n        };\r\n    };\r\n    TxtReader.prototype.newTask = function (action, data) {\r\n        var reqMsg = new RequestMessage(action, data);\r\n        var task = new TxtReaderTask(this.newTaskId(), reqMsg, this);\r\n        this.taskList.push(task);\r\n        if (!this.runningTask) {\r\n            this.runTask(task);\r\n        }\r\n        else {\r\n            this.queuedTaskList.push(task);\r\n            task.state = TxtReaderTaskState.Queued;\r\n        }\r\n        return task;\r\n    };\r\n    TxtReader.prototype.completeTask = function (response) {\r\n        this.runningTask.complete(response);\r\n        this.runningTask = null;\r\n        this.runNextTask();\r\n    };\r\n    TxtReader.prototype.runNextTask = function () {\r\n        if (this.queuedTaskList.length) {\r\n            this.runTask(this.queuedTaskList.shift());\r\n        }\r\n    };\r\n    TxtReader.prototype.runTask = function (task) {\r\n        this.runningTask = task;\r\n        this.worker.postMessage(task.requestMessage);\r\n        task.run();\r\n    };\r\n    TxtReader.prototype.newTaskId = function () {\r\n        var taskListLength = this.taskList.length;\r\n        if (taskListLength === 0) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return this.taskList[taskListLength - 1].id + 1;\r\n        }\r\n    };\r\n    return TxtReader;\r\n}());\r\nexports.TxtReader = TxtReader;\r\n\n\n//# sourceURL=webpack:///./txt-reader.ts?");

/***/ })

/******/ });